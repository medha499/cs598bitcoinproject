# -*- coding: utf-8 -*-
"""Proj1_rev0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13hqgPskNNlRWDRBVvk5ySxBlVIAd-iTm
"""

from google.colab import drive
# drive.mount('/content/drive')
drive.mount("/content/drive", force_remount=True)

import numpy as np, pandas as pd, matplotlib.pyplot as plt
from sklearn.pipeline import Pipeline
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import RobustScaler
from sklearn.impute import SimpleImputer
from sklearn.linear_model import RidgeCV
from sklearn.model_selection import TimeSeriesSplit
from sklearn.metrics import mean_absolute_error, mean_squared_error

PATH       = "/content/drive/MyDrive/UIUC/CS598_Statistic_Learning/Project1/bitcoin.csv"
DATE_COL   = "Date"
TARGET     = "btc_market_price"
FORECAST    = 14
LAG_DAYS   = 3
TRAIN_RATIO = 0.7
VALID_RATIO = 0.10

KEY_FEATS = [
    "btc_market_price",
    # "btc_total_bitcoins",
    "btc_market_cap",
    "btc_trade_volume",
    # "btc_blocks_size",
    # "btc_avg_block_size",
    # "btc_n_orphaned_blocks",
    # "btc_n_transactions_per_block",
    # "btc_median_confirmation_time",
    # "btc_hash_rate",
    # "btc_difficulty",
    # "btc_miners_revenue",
    # "btc_transaction_fees",
    # "btc_cost_per_transaction_percent",
    # "btc_cost_per_transaction",
    # "btc_n_unique_addresses",
    # "btc_n_transactions",
    # "btc_n_transactions_total",
    # "btc_n_transactions_excluding_popular",
    # "btc_n_transactions_excluding_chains_longer_than_100",
    # "btc_output_volume",
    # "btc_estimated_transaction_volume",
    "btc_estimated_transaction_volume_usd"
]

# Helpers
def parse_date_column(df: pd.DataFrame, date_col: str) -> pd.DataFrame:
    if not np.issubdtype(df[date_col].dtype, np.datetime64):
        df[date_col] = pd.to_datetime(df[date_col], errors="coerce")
    return df.sort_values(date_col).reset_index(drop=True)

def make_lagged(df, date_col, target, feat_cols, lag_days, forecast):
    w = df[[date_col] + feat_cols].copy()
    for col in feat_cols:
        for l in range(1, lag_days + 1):
            w[f"{col}_lag{l}"] = w[col].shift(l)
    y_col = f"{target}_t_plus_{forecast}"
    w[y_col] = w[target].shift(-forecast)
    for k in [3, 7]:
        w[f"{target}_rollmean_{k}"] = w[target].rolling(k, min_periods=1).mean().shift(1)
    return w.dropna().reset_index(drop=True), y_col

def temporal_split_by_ratio(df, date_col, train_ratio, valid_ratio):
    n = len(df)
    n_train = int(n * train_ratio)
    n_valid = int(n * valid_ratio)
    return df.iloc[:n_train], df.iloc[n_train:n_train+n_valid], df.iloc[n_train+n_valid:]

def evaluate(y_true, y_pred):
    mae = mean_absolute_error(y_true, y_pred)
    rmse = np.sqrt(mean_squared_error(y_true, y_pred))  # always square root manually
    mape = (np.abs((y_true - y_pred) / np.clip(np.abs(y_true), 1e-8, None))).mean() * 100.0
    return {"MAE": mae, "RMSE": rmse, "MAPE_%": mape}

# Load & Prepare
df = pd.read_csv(PATH)
df = parse_date_column(df, DATE_COL).ffill().bfill()
present_feats = [c for c in KEY_FEATS if c in df.columns]

supervised, y_col = make_lagged(df, DATE_COL, TARGET, present_feats, LAG_DAYS, FORECAST)
X_cols = [c for c in supervised.columns if c not in [DATE_COL, y_col]]

train_df, valid_df, test_df = temporal_split_by_ratio(supervised, DATE_COL, TRAIN_RATIO, VALID_RATIO)
X_train, y_train = train_df[X_cols], train_df[y_col]
X_valid, y_valid = valid_df[X_cols], valid_df[y_col]
X_test,  y_test  = test_df[X_cols],  test_df[y_col]

# Model
pre = ColumnTransformer([
    ("num", Pipeline([
        ("imputer", SimpleImputer(strategy="median")),
        ("scaler",  RobustScaler())
    ]), X_cols)
], remainder="drop")

ridge = Pipeline([
    ("pre", pre),
    ("ridge", RidgeCV(alphas=np.logspace(-2, 2, 7), cv=TimeSeriesSplit(n_splits=3)))
])

ridge.fit(X_train, y_train)
y_pred_valid = ridge.predict(X_valid)
y_pred_test  = ridge.predict(X_test)

print("===== RIDGE RESULTS =====")
print("Validation:", evaluate(y_valid.values, y_pred_valid))
print("Test      :", evaluate(y_test.values,  y_pred_test))

# Save and Plot
preds = pd.DataFrame({
    DATE_COL: test_df[DATE_COL].values,
    "y_true":  y_test.values,
    "y_pred":  y_pred_test
})
preds.to_csv("btc_preds.csv", index=False)

plt.figure(figsize=(12,6))
plt.plot(preds[DATE_COL].values, preds["y_true"].values, label="Actual")
plt.plot(preds[DATE_COL].values, preds["y_pred"].values, label="Predicted")
plt.title(f"BTC Market Price: Actual vs Predicted | Lags={LAG_DAYS} days | Forcast ={FORECAST} days")
plt.xlabel("Date"); plt.ylabel("Price (USD)"); plt.legend()
plt.savefig("btc_pred_plot.png", bbox_inches="tight")
plt.show()